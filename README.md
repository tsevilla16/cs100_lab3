# lab3
For this week's lab, we created a program that will return two types of readability scores for a variety of texts. Each time a file it run, it is storred in a database in order to increase speed of information return if the same file is run through the program again.

We chose to structure our database as follows: The numbercount, lettercount, wordcount, and sentencescount values within our database were all input integers because our tokenizer returns whole number values for the number of characters, words, letters, and sentences in a text. We used a text data type for our hash for each file because the md5File hash function returns a string. We also made the hash column the primary key because the hash uniquely identifies each row for each unique file (our program ensures we never have two rows with the same fileHash). We chose to index on the filehash because our query for matching rows is based on the return value of the hash function. We also hashed the name of the file rather than the contents because we found that when a file with long text contents was hashed, the function would not behave as we anticipated.

We chose to index our database in order to increase query speeds. Athough this is something that occurs at a cost to speed of row insertion, we still chose to index because an insertion to the database is an asynchronous call which means that it will not affect the speed of callback return. Increasing query speed can however affect callback return (as the contents of callback, as well as required calculations, depend on what is returned in the query of the database). Thus, for our program it made sense to index on the file hash.

We chose to implement our hash function synchronously because querying the database requires the hash of the file, so if hashed the file asynchronously it would still require the return value from the hash function and we would have to nest our other code in the callback for the asynchronous call.

We chose to move insertdbrow into its own function for program cleanliness, but we nested other processes that could theoretically otherwise been in their own functions as they were reliant on prior returns and we needed those processes to occur in order.